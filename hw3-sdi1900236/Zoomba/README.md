Στην άσκηση αυτή χρησιμοποίησα τη μέθοδο της αναζήτησης σε δέντρο.
Η κεντρική ιδέα της λύσης την οποία έγραψα είναι η η δημιουργία ενός δέντρου (node) ο κάθε κόμβος του οποίου αντιστοιχεί σε ένα τετράγωνο του παζλ και μιας στοίβας-μέτωπο (front).
Το δέντρο αποτελείται από τις συντεταγμένες x, y και δείκτες στις δομές-παιδιά του κάθε κόμβου (left-right-up-down) και στον κόμβο-γονέα του.
Η στοίβα-μέτωπο (front) αποτελείται από έναν δείκτη σε δομή τύπου node και έναν δείκτη στο επόμενο στοιχείο της στοίβας.
Η χρησιμότητα της στοίβας είναι στο να αποθηκεύει όλους τους κόμβους (τετράγωνα) τα οποία αντιστοιχούν σε μονοπάτια που έχει βρει ο αλγόριθμος σε κάθε επανάληψη.
Ο αλγόριθμος διατηρεί δύο πίνακες, τον map[N][N] ο ο οποίος κρατά τα στοιχεία του παζλ (0 ή 1) και τον cost[N][N] ο οποίος κρατά το ελάχιστο κόστος που έχει βρει ο αλγόριθμος για να φτάσει στο τετράγωνο των συντεταγμένων του.
Προφανώς ο cost[N][N] αρχικοποιείται σε Ν^2 ώστε την πρώτη φορά που φτάνει σε κάθε τετράγωνο να αρχικοποιεί με το βάθος του, δηλαδή με το κόστος του συγκεκριμένου μονοπατιού.
Σε κάθε επανάληψη, το μέτωπο ανανεώνεται και το "βάθος" της αναζήτησης αυξάνεται κατά ένα.
Επίσης, σε κάθε επανάληψη ο αλγόριθμος ελέγχει ένα προς ένα τα στοιχεία της στοίβας μετώπου και εφόσον κάποιο αυτά είναι το τελικό τετράγωνο, σταματάει τις επαναλήψεις και επιστρέφει τον κόμβο αυτό.
Σε περίπτωση που αυτό δε συμβαίνει, ελέγχει το βάθος το μονοπατιού ως το τετράγωνο αυτό και μόνο εφόσον αυτό είναι μικρότερο από το ελάχιστο, ενημερώνει τον πίνακα cost[Ν][Ν] και προχωρά σε expansion, δηλαδή προσθέτει τι δυνατές κινήσεις (left/right/up/down) στο αντίστοιχο μονοπάτι.
Ο έλεγχος αυτός σε σχέση με τον πίνακα cost γίνεται ώστε να αποφύγουμε να συνεχίζουμε μονοπάτια που έχουν μεγαλύτερο κόστος ως το συγκεκριμένο τετράγωνο και άρα δεν έχει νόημα η διερεύνησή τους.
Η συνάρτηση expand() δημιουργεί 4 συνατές συνέχειες σε κάθε μονοπάτι, left/right/up/down, όπου αυτό είναι δυνατό, δηλαδή όπου δεν υπάρχει blockage και δεν βγαίνει εκτός του παζλ.
Κάθε κόμβο που προσθέτει η expand() τον προσθέτει επίσης και στην στοίβα του μετώπου, ώστε να ελεγθούν στη συνέχεια όλα τα δυνατά μονοπάτια του επόμενου βάθους.
Κάθε επανάληψη προφανώς αντοιστοιχεί σε ένα βάθος, δηλαδή σε κάθε επανάληψη το κόστος ως το τετράγωνο που φτάνει το κάθε μονοπάτι είναι ίσο με το βάθος του μετώπου της αναζήτησης.
Οι επαναλήψεις ολοκληρώνονται με δύο πιθανούς τρόπους: α) κάποιο μονοπάτι φτάνει στο target ή β) σε κάποια επανάληψη δεν υπάρχει κανένα expansion, το οποίο σημαίνει ότι έχουμε φτάσει σε αδιέξοδο και το παζλ είναι αδύνατο.
Όταν η συνάρτηση αναζήτησης search_tree() επιστρέψει τον κόμβο που αντιστοιχεί στο τελικό τετράγωνο, ο αλγόριθμος κάνει μια τελευταία αναζήτηση από τον κόμβο αυτό προς τα πάνω, δηλαδή πηγαίνοντας κάθε φορά στον κόμβο-γονέα του και φτάνοντας έτσι στον αρχικό.
Αν συνεχεία, για κάθε μετκαίνηση βρίσκουμε την κίνηση που αντιστοιχεί σε αυτή (left/right/up/down) και στο τέλος αντιστρέφουμε τη διαδοχή των γραμμάτων ώστε να πάρουμε τη σειρά των κινήσεων από την αρχή προς το τέλος (και όχι ανάποδα).
Με αυτή τη σειρά εκτυπώνει ο αλγόριθμος το αποτέλεσμα και ολοκληρώνεται.
